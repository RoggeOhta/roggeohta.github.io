<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码测试</title>
      <link href="/dai-ma-ce-shi.html"/>
      <url>/dai-ma-ce-shi.html</url>
      
        <content type="html"><![CDATA[<h1 id="堆排序-Heap-sort"><a href="#堆排序-Heap-sort" class="headerlink" title="堆排序(Heap sort)"></a>堆排序(Heap sort)</h1><p>注意，这里的堆指的是二叉堆，不是堆栈的堆。</p><p>堆的概念：堆一种近似完全二叉树。<br>最大堆和最小堆：最大堆在堆得基础上满足父节点一定比子节点大的性质，最小堆就是满足满足父节点一定比子节点小的性质</p><p>堆在实际数据结构中用一个数组表示，通过几个操作来获得父节点，左叶和右叶</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">parent</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">left</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">right</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>==通常编程语言的数组都是0开始的，所以这里要做特殊处理==</p><hr><p>我们还需要保持堆特性的函数<br>这个函数可以从指定的位置开始，让它的子节点满足堆特性</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">maxHeapify</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token function">left</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">right</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> largest<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> size <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        largest <span class="token operator">=</span> l<span class="token punctuation">;</span>    <span class="token keyword">else</span>        largest <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;=</span> size <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span>        largest <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">maxHeapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>==swap是原地交换两个参数的值==</p><p>maxHeapify的动作如图<br><img src="./images/1581680643022.png" alt="enter description here"></p><hr><p>建立堆函数</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">maxHeapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>建堆过程图：<br><img src="./images/1581681060013.png" alt="enter description here"></p><p>建立堆函数很简单，只有一个地方需要注意，那就是他是从size/2开始的，因为建立堆是自底向上的</p><p><strong>循环不变式</strong>：每次循环开始时，大于当前索引i的节点是最大堆的父节点</p><p>开始：在size/2开始，大于size/2的都是无叶节点，满足性质<br>保持：因为每次结束时都调用maxHeapify，这个函数的性质决定了i节点将会是一个最大堆的父节点<br>结束：i=0，所有节点都是最大堆的父节点了</p><p>因为这是个二叉树，数高lgn，所以<strong>maxHeapify的复杂度为lgn</strong><br>所以最终<strong>建堆的复杂度为O(nlgn)</strong></p><p>根据观察和细化分析，我们可以得到一个更接近的复杂度上界。<br>因为我们发现，大部分的节点都集中在底层，所以这个复杂度应该会更低<br>比如一个4层的堆，比较4次的最多一个节点，比较3次的最多两个节点，比较2次的最多4个节点，比较1次的最多8个节点</p><p>换句话说，有1/2的节点向下比较了1次，有1/4的节点向下比较了2次…</p><p>这是一个调和级数，收敛在2，说明平均向下比较次数在2次左右<br><img src="./images/1581682968078.png" alt="enter description here"></p><p>所以建堆的复杂度为<strong>O(n)</strong></p><hr><p>堆排序</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">maxHeapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>堆排序的复杂度为O(nlgn),因为maxHepify的复杂度为lgn</p><p>堆排序过程图<br><img src="./images/1581683075083.png" alt="enter description here"></p><h1 id="破解维吉尼亚密码"><a href="#破解维吉尼亚密码" class="headerlink" title="破解维吉尼亚密码"></a>破解维吉尼亚密码</h1><p>维吉尼亚密码是一种多表密码，本质上就是凯撒密码的组合。<br>维吉尼亚密码的规则是最高对每一个字母都做一次移位，来达到增强破解难度的目的。<br>举个例子，秘钥(1,2,3),那就是对前三个字母，分别移位1,2,3位。然后对接下来三个字母，也移位1,2,3</p><p>下图这个表示往回拨的，也就是减法移位<br><img src="./images/1584256393756.png" alt="enter description here"></p><p>维吉尼亚密码确实很难破解，但是也不是没有办法。不过就是有点看运气。<br>==维吉尼亚密码的破解非常依赖原文本的长度和规律程度，长度越长，原文本越像英文文本，破解成功的几率就越高==</p><p>破解维吉尼亚密码分为两个步骤：<br>1.猜解秘钥长度<br>2.猜解秘钥</p><p>第一步很关键，做得好的话就成功了一半。<br>猜解秘钥长度有两种办法，一种是找秘钥中相同的子串，通过他们的距离的最大公约数来判断长度。第二种是重合指数法。</p><p>这里记录一下重合指数法。<br>重合指数法的原理是，正常的有意义英文文本的字母分布是由一定的规律的，这个是基于统计的。每一段文本，都可以通过字母频率得出一个重合指数(Coincidence Index)简称CI，这个东西的意思就是你在这段文本中任意取两个字符重合的概率。<br>正常的英文文本的CI应该在0.065左右，而随机的文本的CI一般在0.035左右。<br>而又因为，维吉尼亚密码在每个秘钥段上都只是对字母做了移位，字母的分布本质上没有变化，只是字母不一样了而已。<br>==这句话可以这样理解，比如某段文本的字母E比较多，在移位之后，E变成了H，但是不论是原文本还是密文的E和H的数量都是一样多的，其他的字母也是一样，重合指数不判断字母的实际是什么，只判断字母的分布情况==<br>==从另一个角度来说，重合指数法是基于凹凸程度来判断的==<br>根据这个，我们可以一个个试秘钥长度，找出最接近0.065的作为备选。</p><p><code>!$$ CI=\sum _{i=A} ^Z \frac{N_i(N_i-1)}{L(L-1)} $$</code><br>==其中i是从A到Z的字母，Ni是对应的i的字母在文本中的数量 L是文本的总长度==</p><pre class=" language-python"><code class="language-python"><span class="token triple-quoted-string string">"""Compute the coincidence index"""</span><span class="token keyword">def</span> <span class="token function">co_index</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>    alpha<span class="token operator">=</span><span class="token string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>    text<span class="token operator">=</span>text<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>    count<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true"># Letter count</span>    <span class="token keyword">for</span> letter <span class="token keyword">in</span> alpha<span class="token punctuation">:</span>        count<span class="token punctuation">[</span>letter<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>    <span class="token keyword">for</span> letter <span class="token keyword">in</span> alpha<span class="token punctuation">:</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> text<span class="token punctuation">:</span>            <span class="token keyword">if</span> c<span class="token operator">==</span>letter<span class="token punctuation">:</span>                count<span class="token punctuation">[</span>letter<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>    co_index<span class="token operator">=</span><span class="token number">0</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> count<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">continue</span>        N<span class="token operator">=</span>item<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>        L<span class="token operator">=</span>len<span class="token punctuation">(</span>text<span class="token punctuation">)</span>        co_index<span class="token operator">+=</span><span class="token punctuation">(</span>N<span class="token operator">*</span><span class="token punctuation">(</span>N<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>L<span class="token operator">*</span><span class="token punctuation">(</span>L<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> co_index</code></pre><p>利用这个来构建一个自动猜解秘钥的函数<br>这里的heapq是一个python库，最后一句的意思是，根据匿名函数的标准，取列表中最小的三个，这里是取与0.065差距最小的三个秘钥长度供参考。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">guess_length</span><span class="token punctuation">(</span>cipher<span class="token punctuation">)</span><span class="token punctuation">:</span>    res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        index<span class="token operator">=</span>co_index<span class="token punctuation">(</span>cipher<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">,</span><span class="token string">"{:.4f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"{:.4f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>abs<span class="token punctuation">(</span><span class="token number">0.065</span><span class="token operator">-</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> heapq<span class="token punctuation">.</span>nsmallest<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>res<span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> res<span class="token punctuation">:</span>res<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>接下来要解决的问题就是猜解秘钥<br>维吉尼亚密码的本质就是不同的凯撒密码的组合，一旦知道了秘钥的长度，我们就可以分列破解凯撒密码了<br>猜解秘钥其实也是使用和CI类似的方法，只是这次我们要判断具体字母的分布情况了，就是要判断A应该占比多少，B应该占比多少这样。如果用这样的方法还是类似0.065，那可能性就很大了。</p><pre class=" language-python"><code class="language-python"><span class="token triple-quoted-string string">"""Analysis the letter frequency to guess the Caesar cipher"""</span><span class="token keyword">def</span> <span class="token function">frequencyAnalysis</span><span class="token punctuation">(</span>cipher<span class="token punctuation">)</span><span class="token punctuation">:</span>    frequencies <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">"e"</span><span class="token punctuation">:</span> <span class="token number">0.12702</span><span class="token punctuation">,</span> <span class="token string">"t"</span><span class="token punctuation">:</span> <span class="token number">0.09056</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token number">0.08167</span><span class="token punctuation">,</span> <span class="token string">"o"</span><span class="token punctuation">:</span> <span class="token number">0.07507</span><span class="token punctuation">,</span> <span class="token string">"i"</span><span class="token punctuation">:</span> <span class="token number">0.06966</span><span class="token punctuation">,</span>        <span class="token string">"n"</span><span class="token punctuation">:</span> <span class="token number">0.06749</span><span class="token punctuation">,</span> <span class="token string">"s"</span><span class="token punctuation">:</span> <span class="token number">0.06327</span><span class="token punctuation">,</span> <span class="token string">"h"</span><span class="token punctuation">:</span> <span class="token number">0.06094</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">:</span> <span class="token number">0.05987</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">:</span> <span class="token number">0.04253</span><span class="token punctuation">,</span>        <span class="token string">"l"</span><span class="token punctuation">:</span> <span class="token number">0.04025</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">:</span> <span class="token number">0.02782</span><span class="token punctuation">,</span> <span class="token string">"u"</span><span class="token punctuation">:</span> <span class="token number">0.02758</span><span class="token punctuation">,</span> <span class="token string">"m"</span><span class="token punctuation">:</span> <span class="token number">0.02406</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">:</span> <span class="token number">0.02360</span><span class="token punctuation">,</span>        <span class="token string">"f"</span><span class="token punctuation">:</span> <span class="token number">0.02228</span><span class="token punctuation">,</span> <span class="token string">"g"</span><span class="token punctuation">:</span> <span class="token number">0.02015</span><span class="token punctuation">,</span> <span class="token string">"y"</span><span class="token punctuation">:</span> <span class="token number">0.01974</span><span class="token punctuation">,</span> <span class="token string">"p"</span><span class="token punctuation">:</span> <span class="token number">0.01929</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">0.01492</span><span class="token punctuation">,</span>        <span class="token string">"v"</span><span class="token punctuation">:</span> <span class="token number">0.00978</span><span class="token punctuation">,</span> <span class="token string">"k"</span><span class="token punctuation">:</span> <span class="token number">0.00772</span><span class="token punctuation">,</span> <span class="token string">"j"</span><span class="token punctuation">:</span> <span class="token number">0.00153</span><span class="token punctuation">,</span> <span class="token string">"x"</span><span class="token punctuation">:</span> <span class="token number">0.00150</span><span class="token punctuation">,</span> <span class="token string">"q"</span><span class="token punctuation">:</span> <span class="token number">0.00095</span><span class="token punctuation">,</span>        <span class="token string">"z"</span><span class="token punctuation">:</span> <span class="token number">0.00074</span>        <span class="token punctuation">}</span>    alpha<span class="token operator">=</span><span class="token string">"abcdefghijklmnopqrstuvwxyz"</span>    cipher<span class="token operator">=</span>cipher<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>    count<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    res<span class="token operator">=</span><span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> alpha<span class="token punctuation">:</span>        count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> cipher<span class="token punctuation">:</span>        count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> alpha<span class="token punctuation">:</span>        res<span class="token operator">+=</span><span class="token punctuation">(</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>len<span class="token punctuation">(</span>cipher<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span>frequencies<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">return</span> res</code></pre><p>首先是各个字母的频率列表，然后与对应的字母的实际占比相乘。然后汇总相加，看结果是否接近0.065<br><code>!$$ \sum _{i=A} ^Z \frac{N_i}{L}(frequcencies[i]) $$</code><br>这个公式，如果字母的期望分布于实际接近，那么相当于实际分布的平方，实际上也是做统计方法</p><p>下面这个猜解函数扩展到了52个字母</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">guess_key</span><span class="token punctuation">(</span>cipher<span class="token punctuation">,</span>key_length<span class="token punctuation">)</span><span class="token punctuation">:</span>    alpha <span class="token operator">=</span> <span class="token string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</span>    res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>key_length<span class="token punctuation">)</span><span class="token punctuation">:</span>        cl<span class="token operator">=</span>cipher<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">:</span>key_length<span class="token punctuation">]</span>        key_guess<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            cl_shifted<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cl<span class="token punctuation">:</span>                numa <span class="token operator">=</span> alpha<span class="token punctuation">.</span>find<span class="token punctuation">(</span>c<span class="token punctuation">)</span>                ciphernuma <span class="token operator">=</span> <span class="token punctuation">(</span>numa <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">52</span>                cl_shifted<span class="token punctuation">.</span>append<span class="token punctuation">(</span>alpha<span class="token punctuation">[</span>ciphernuma<span class="token punctuation">]</span><span class="token punctuation">)</span>            index<span class="token operator">=</span>frequencyAnalysis<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>cl_shifted<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> index<span class="token punctuation">:</span>                index<span class="token operator">=</span><span class="token number">0</span>            key_guess<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"{:.4f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"{:.4f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>abs<span class="token punctuation">(</span><span class="token number">0.065</span><span class="token operator">-</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        candi<span class="token operator">=</span>heapq<span class="token punctuation">.</span>nsmallest<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>key_guess<span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> key_guess<span class="token punctuation">:</span>key_guess<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>candi<span class="token punctuation">)</span>    <span class="token keyword">return</span> res</code></pre><p>同理，利用这个函数再创建一个猜解各列凯撒密码的函数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">guess_key</span><span class="token punctuation">(</span>cipher<span class="token punctuation">,</span>key_length<span class="token punctuation">)</span><span class="token punctuation">:</span>    alpha <span class="token operator">=</span> <span class="token string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</span>    res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>key_length<span class="token punctuation">)</span><span class="token punctuation">:</span>        cl<span class="token operator">=</span>cipher<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">:</span>key_length<span class="token punctuation">]</span>        key_guess<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            cl_shifted<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> cl<span class="token punctuation">:</span>                numa <span class="token operator">=</span> alpha<span class="token punctuation">.</span>find<span class="token punctuation">(</span>c<span class="token punctuation">)</span>                ciphernuma <span class="token operator">=</span> <span class="token punctuation">(</span>numa <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">52</span>                cl_shifted<span class="token punctuation">.</span>append<span class="token punctuation">(</span>alpha<span class="token punctuation">[</span>ciphernuma<span class="token punctuation">]</span><span class="token punctuation">)</span>            index<span class="token operator">=</span>frequencyAnalysis<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>cl_shifted<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> index<span class="token punctuation">:</span>                index<span class="token operator">=</span><span class="token number">0</span>            key_guess<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">"{:.4f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"{:.4f}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>abs<span class="token punctuation">(</span><span class="token number">0.065</span><span class="token operator">-</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        candi<span class="token operator">=</span>heapq<span class="token punctuation">.</span>nsmallest<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span>key_guess<span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> key_guess<span class="token punctuation">:</span>key_guess<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>candi<span class="token punctuation">)</span>    <span class="token keyword">return</span> res</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mathjax测试</title>
      <link href="/mathjax-ce-shi.html"/>
      <url>/mathjax-ce-shi.html</url>
      
        <content type="html"><![CDATA[<h2 id="ndS的推导-一般化"><a href="#ndS的推导-一般化" class="headerlink" title="ndS的推导-一般化"></a>ndS的推导-一般化</h2><p>对于一个二元函数，空间内每一个点都可以被两个参数给参数化<br>$$ \left{\begin{matrix}<br>x=x(u,v)\<br>y=y(u,v)\<br>z=z(u,v)<br>\end{matrix}\right. $$</p><p>我们把同时可以把三个分量结合起来<br>$$  (x,y,z)=\vec{r}=\vec{r}(u,v)  $$</p><p>现在我们来表示U和V<br>$$<br>\vec{U}=&lt;\frac{\partial \vec{r}}{\partial u}&gt;\Delta u<br>\vec{U}=&lt;\frac{\partial \vec{r}}{\partial v}&gt;\Delta v<br>$$<br>==太长了就简写了，这个包含了三个分量，分别对向量r的x,y,z做u和v的偏导==</p><p>然后依然是<code>!$ \hat{n}dS=\vec{U}\times \vec{V} $</code><br>$$  \vec{U}\times \vec{V}=(\frac{\partial \vec{r}}{\partial u}\times \frac{\partial \vec{r}}{\partial v})dudv $$<br>如果你把它展开的话就是雅各比行列式 ==(Here we are again)==</p><p>这是一般化的解，如果换成dxdy就是上面那样</p><h1 id="高斯散度定理（Divergence-theorem"><a href="#高斯散度定理（Divergence-theorem" class="headerlink" title="高斯散度定理（Divergence theorem)"></a>高斯散度定理（Divergence theorem)</h1><p>散度定理基本内容就是一个向量场穿过一个三维闭合曲面的通量等于这个闭合曲面围起来面积的散度的积分</p><p>$$  \iint _S F\cdot n dA=\iiint _R divF\ dV  $$<br>==这里左边的二重积分应该要有个环强调是闭合曲面，但是latex打不出来==</p><p>复习一下散度的定义：<br>$$  \triangledown·(V(x,y))=\frac{\partial V_x(x,y)}{\partial x}+\frac{\partial V_y(x,y)}{\partial y}  $$</p><h2 id="散度定理证明"><a href="#散度定理证明" class="headerlink" title="散度定理证明"></a>散度定理证明</h2><p>我们把一个闭合曲面（三维物体）细分成无数个小正方体<br>我们可以得到一个近似公式<br>$$  flux\ of\ F\ over\ faces\cong (div\ F)\Delta V  $$</p><p>因为内部的散度之间互相抵消了，我们计算的散度只存在于边界上（表面）<br>$$  \iint _s F\cdot ndA\cong \iiint _R divF\ dV  $$<br>这样理解的话左边的式子就是闭合曲面在向量场上的通量<br>右边是体积的散度积分，但是体积内部的散度都互相抵消了，所以本质上还是只算了表面的，也就是通量</p><p>==当然这是个非常粗糙的证明（非常不严谨）==</p><h1 id="三维线积分"><a href="#三维线积分" class="headerlink" title="三维线积分"></a>三维线积分</h1><p>3D的线积分也是算做工，和2D没啥区别，就是加了一个z轴<br>$$  work=\int _c \vec{F}d\vec{r}  $$<br>$$  \vec{F}=Pi+Qj+Rk\ d\vec{r}=&lt; dx,dy,dz &gt;  $$<br>$$  \int _c Pdx+Qdy+Rdz  $$</p><h1 id="判断三维向量场是否是梯度场"><a href="#判断三维向量场是否是梯度场" class="headerlink" title="判断三维向量场是否是梯度场"></a>判断三维向量场是否是梯度场</h1><p>依然是判断混合导数是否相等，只不过要根据组合法则对所有轴的分量都判断相等才行</p><p>$$  P_y=Q_x \ P_z=R_x \ Q_z=R_y  $$</p><p>以上全部满足即为梯度场</p><h1 id="三维梯度场的势函数"><a href="#三维梯度场的势函数" class="headerlink" title="三维梯度场的势函数"></a>三维梯度场的势函数</h1><p><strong>线积分法：</strong><br>根据路径无关定理，以及线积分基本定理的内容<br>$$  f(x,y,z)=\int _c ▽f·dR+f(0,0,0)  $$</p><p>同时把这个线积分拆成三个线积分，分别是x,y,z三个分量即可得到势函数</p><p><strong>反导数法:</strong><br>和二维类似的方法<br><img src="./images/1572951272906.png"></p><h1 id="斯托克斯定理-Stokes-Formula"><a href="#斯托克斯定理-Stokes-Formula" class="headerlink" title="斯托克斯定理(Stokes Formula)"></a>斯托克斯定理(Stokes Formula)</h1><p>$$  \oint _c F·dR=\iint _S (curl F)·\hat{n}dA  $$</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
